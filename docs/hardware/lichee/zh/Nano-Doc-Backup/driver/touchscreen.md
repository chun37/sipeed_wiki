电容触摸屏适配
==============

本篇需要启动linux系统，所需用到的工具：

 -   ts-lib
    -   ts\_test
    -   ts\_calibrate
 -   evtest

在前文设备树中，我们就已经对i2c接口的电容触摸屏做了初始化，以下是进行电容触摸屏的调整与测试：

```
ls /dev/input   # 查看是否存在input/event0

# 若不存在，找到触摸模块并加载 
insmod goodix.ko   
# 如根文件系统未找到goodix.ko，请在linux源码的output目录下查找并放入根文件系统下

# 若存在
evtest /dev/input/event0  # 使用evtest测试输入的xy坐标数据

# 直观的测试
ts_test

# 触摸校准工具
ts_calibrate
```

但是 ts\_calibrate 仅仅是将校准参数写到 /etc/pointcrl文件中，适用于微调，tslib下的工具如 ts\_test将会读取此校准文件而表现的触摸正常；而 evtest 读取原始数据、littlevGL程序调用 event0的输入时，并未去解析该参数文件。同样也有一定可能是该触摸屏内置参数即为错误的，难以进行校准。

测试时，发现xy轴输出互相调换了，请添加或去掉 gt911节点下 的 *touchscreen-swapped-x-y* 属性

若是发现触摸屏输出跳动大，屏幕上有些地方检测不到输出，此处采取修改驱动的办法进行解决：通过 i2c 向 电容触摸芯片GT911 写入固定的参数(相当于重刷GT911的固件)；

``` 
// 找到一个加载模块时会调用到的函数 

static void goodix_read_config(struct goodix_ts_data *ts)
{
    u8 config[GOODIX_CONFIG_MAX_LENGTH];
    int error, i;

    error = goodix_i2c_read(ts->client, ts->chip->config_addr,
                            config, ts->chip->config_len);

/* end of the code user added */

    u8 check_sum = 0;         //校验和

    /* 800*480屏使用 */
    u8 write2gt911[GOODIX_CONFIG_911_LENGTH] = {0x42, 0xe0, 0x01, 0x20, 0x03, 0x0a, 0x35, 0x00, 0x01, 0x08, 0x28, 0x08, 0x5a, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0x57, 0x5c, 0xb5, 0x06, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x82, 0x94, 0xc5, 0x02, 0x07, 0x00, 0x00, 0x04, 0x96, 0x4a, 0x00, 0x85, 0x54, 0x00, 0x77, 0x5f, 0x00, 0x6a, 0x6c, 0x00, 0x5f, 0x7a, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00};

    /* 480*272屏使用 */
    u8 write2gt911[GOODIX_CONFIG_911_LENGTH] = {0x42, 0xe0, 0x01, 0x10, 0x01, 0x0a, 0x3d, 0x00, 0x02, 0x08, 0x28, 0x08, 0x64, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0xc8, 0xca, 0x40, 0x04, 0x00, 0x00, 0x00, 0x61, 0x02, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfa, 0x94, 0xd5, 0xf4, 0x07, 0x00, 0x00, 0x04, 0x86, 0xa7, 0x00, 0x82, 0xb7, 0x00, 0x80, 0xc8, 0x00, 0x7d, 0xda, 0x00, 0x7c, 0xef, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x01};

    write2gt911[GOODIX_CONFIG_911_LENGTH - 1] = 0x01; //update flag
    for (i = 0; i < (GOODIX_CONFIG_911_LENGTH - 2); i++)    //校验和计算
        check_sum += write2gt911[i];
    write2gt911[184] = (~check_sum) + 1; //checksum

    error = goodix_i2c_write(ts->client, ts->chip->config_addr, write2gt911, GOODIX_CONFIG_911_LENGTH);

    dev_warn(&ts->client->dev,
            "updated the user defined config \n",
            error);
    /* Let the firmware reconfigure itself, so sleep for 10ms */
    usleep_range(10000, 11000);

    error = goodix_i2c_read(ts->client, ts->chip->config_addr,
                            config, ts->chip->config_len);


    for (i = 0; i < GOODIX_CONFIG_911_LENGTH; i++)
    {
        printk("Config Reg 0x%.4X : 0x%.2x,",
            i + 0x8047, config[i]);
    }
/* end of the code user added */

/* -----------略------------- */
}
```

将此驱动编译成模块，使用 `insmod`加载模块后作为修正屏幕参数所用，控制台将会输出gt911各寄存器的参数；修改完毕后使用`rmmod goodix.ko` 卸载模块，重新加载正常的驱动。

若再测试时，发现xy轴输出互相调换了，请添加或去掉gt911节点下的*touchscreen-swapped-x-y* 属性

> **交流与答疑**
> 对于本节内容，如有疑问，欢迎到 [模组使用交流帖](http://bbs.lichee.pro/d/24--) 提问或分享经验。
